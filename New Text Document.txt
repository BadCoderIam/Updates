# Run-NewHirePhotoJob.ps1
# One-shot: prompts user, connects to Graph (USGov) interactively,
# Applies the standard PNG to group members only when needed,
# Avoids downloading user photos; uses snapshot of last applied hash + periodic recheck.

# -------- Modules (minimal) --------
Import-Module Microsoft.Graph.Authentication -ErrorAction Stop
Import-Module Microsoft.Graph.Groups -ErrorAction Stop
Import-Module Microsoft.Graph.Users -ErrorAction Stop
# Optional if you call Get-MgOrganization in Ensure-Graph:
# Import-Module Microsoft.Graph.Identity.DirectoryManagement -ErrorAction Stop

# -------- Config --------
$GroupName        = "DYN-ActiveUsers"
$PhotoFilePath    = "C:\Scripts\android-chrome-512x512.png"
$SnapshotPath     = "C:\Scripts\activeusers_snapshot.json"
$GraphEnvironment = "USGov"
$RecheckDays      = 30     # Days after which we re-apply even if snapshot matches (0 = never recheck)

# -------- UI Prompt (requires -STA in launcher) --------
Add-Type -AssemblyName System.Windows.Forms
$rc = [System.Windows.Forms.MessageBox]::Show(
    "Run the Photo job now?`nYou'll be prompted to sign in to Microsoft Graph ($GraphEnvironment).",
    "Onboarding",
    [System.Windows.Forms.MessageBoxButtons]::OKCancel,
    [System.Windows.Forms.MessageBoxIcon]::Information
)
if ($rc -ne [System.Windows.Forms.DialogResult]::OK) { Write-Host "Cancelled by user."; exit 0 }

# -------- Graph Helpers --------
function Ensure-Graph {
    $scopes = @("User.ReadWrite.All","GroupMember.Read.All","Group.Read.All")

    try { $ctx = Get-MgContext -ErrorAction Stop } catch { $ctx = $null }
    $needConnect = $true
    if ($ctx) {
        $envOk = ($ctx.Environment -eq $GraphEnvironment)
        $scopeSet = @($ctx.Scopes | ForEach-Object { $_.ToLower() })
        $scopesOk = ($scopes | ForEach-Object { $scopeSet -contains $_.ToLower() }) -notcontains $false
        $needConnect = -not ($envOk -and $scopesOk)
        if (-not $needConnect) {
            try { Get-MgOrganization -ErrorAction Stop | Out-Null } catch { $needConnect = $true }
        }
    }
    if ($needConnect) {
        Connect-MgGraph -Environment $GraphEnvironment -Scopes $scopes -NoWelcome
    }
    try {
        $ctx = Get-MgContext
        Write-Host ("Graph context: Account={0} Tenant={1} Env={2}" -f $ctx.Account, $ctx.TenantId, $ctx.Environment)
    } catch { Write-Host "Failed to read Graph context: $($_.Exception.Message)"; throw }
}

# -------- Snapshot helpers (map of UPN -> object) --------
function Load-Snapshot {
    if (Test-Path $SnapshotPath) {
        try {
            $raw = Get-Content $SnapshotPath -Raw
            if (-not $raw) { return @{} }
            $json = $raw | ConvertFrom-Json
            # Support legacy array format (list of UPNs)
            if ($json -is [System.Collections.IEnumerable] -and -not ($json.PSObject.Properties.Name -contains 'PSObject')) {
                $map = @{}
                foreach ($upn in $json) {
                    $map[$upn] = [ordered]@{
                        lastHash        = $null
                        lastSetUtc      = $null
                        lastVerifiedUtc = $null
                    }
                }
                return $map
            }
            # If already an object/dictionary
            if ($json -is [hashtable] -or $json.PSObject.Properties.Count -gt 0) {
                # Convert PSCustomObject to hashtable
                $map = @{}
                foreach ($p in $json.PSObject.Properties) {
                    $map[$p.Name] = $p.Value
                }
                return $map
            }
            return @{}
        } catch {
            Write-Host "‚ö†Ô∏è Failed to parse snapshot, starting fresh: $($_.Exception.Message)"
            return @{}
        }
    } else {
        return @{}
    }
}

function Save-Snapshot($map) {
    # Ensure it's serializable
    $obj = [ordered]@{}
    foreach ($k in $map.Keys) {
        $obj[$k] = $map[$k]
    }
    $obj | ConvertTo-Json -Depth 6 | Set-Content -Path $SnapshotPath -Encoding UTF8
}

# -------- Job Logic (fast path, no downloads) --------
function Run-SetPhotoForGroupMembers {
    if (!(Test-Path $PhotoFilePath)) { Write-Host "‚ùå Photo file not found: $PhotoFilePath"; return }

    Ensure-Graph

    # Precompute reference hash once
    $refHash = (Get-FileHash -Path $PhotoFilePath -Algorithm MD5).Hash
    $nowUtc  = [DateTime]::UtcNow

    # Load snapshot map
    $snap = Load-Snapshot

    # Get group
    $group = Get-MgGroup -Filter "DisplayName eq '$GroupName'"
    if (-not $group) { Write-Host "‚ùå Group '$GroupName' not found."; return }

    # Current members (users only)
    $members = Get-MgGroupMember -GroupId $group.Id -All | Where-Object {
        $_.AdditionalProperties['@odata.type'] -eq '#microsoft.graph.user'
    }

    $updated = 0; $skipped = 0; $errors = 0

    foreach ($m in $members) {
        $upn = $m.AdditionalProperties['userPrincipalName']
        if ([string]::IsNullOrWhiteSpace($upn)) { continue }

        # Snapshot entry
        if (-not $snap.ContainsKey($upn)) {
            $snap[$upn] = [ordered]@{
                lastHash        = $null
                lastSetUtc      = $null
                lastVerifiedUtc = $null
            }
        }

        $entry = $snap[$upn]
        $lastHash = $entry.lastHash
        $lastVerifiedUtc = $entry.lastVerifiedUtc

        # Decide if we can SKIP without any API:
        $withinRecheck = $false
        if ($RecheckDays -gt 0 -and $lastVerifiedUtc) {
            $withinRecheck = ($nowUtc - [datetime]$lastVerifiedUtc).TotalDays -lt $RecheckDays
        } elseif ($RecheckDays -eq 0) {
            $withinRecheck = $true
        }

        if ($lastHash -eq $refHash -and $withinRecheck) {
            # Trust snapshot; no API call
            Write-Host "‚è≠Ô∏è  Skipping $upn (snapshot says photo already applied; within recheck window)"
            $skipped++
            continue
        }

        # Enforce standard image with ONE API call (upload only)
        try {
            Set-MgUserPhotoContent -UserId $upn -InFile $PhotoFilePath
            $entry.lastHash        = $refHash
            $entry.lastSetUtc      = $nowUtc.ToString("o")
            $entry.lastVerifiedUtc = $nowUtc.ToString("o")
            Write-Host "‚úÖ Applied photo: $upn"
            $updated++
        } catch {
            Write-Host "‚ùå Error on $upn $($_.Exception.Message)"
            $errors++
        } finally {
            Start-Sleep -Milliseconds 120  # gentle pacing
        }

        # Save back entry
        $snap[$upn] = $entry
    }

    # Remove snapshot entries for users no longer in the group (optional cleanup)
    $currentSet = [System.Collections.Generic.HashSet[string]]::new([string[]]($members | ForEach-Object { $_.AdditionalProperties['userPrincipalName'] }))
    foreach ($key in @($snap.Keys)) {
        if (-not $currentSet.Contains($key)) { $snap.Remove($key) }
    }

    try {
        Save-Snapshot -map $snap
        Write-Host "üíæ Snapshot updated: $SnapshotPath"
    } catch {
        Write-Host "‚ö†Ô∏è Failed to write snapshot: $($_.Exception.Message)"
    }

    Write-Host ("Summary: Updated={0} Skipped={1} Errors={2}" -f $updated, $skipped, $errors)
}

# -------- Run --------
Run-SetPhotoForGroupMembers
